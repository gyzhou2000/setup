

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>gammagl.data.graph &mdash; GammaGL 0.2.0 documentation</title>
  

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html" class="icon icon-home"> GammaGL
          

          
          </a>

          
            
            
              <div class="version">
                0.2.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption" role="heading"><span class="caption-text">NOTES</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../notes/installation.html">Installation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../notes/installation.html#system-requrements">System requrements</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../notes/installation.html#backend">Backend</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../notes/installation.html#install">Install</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../notes/installation.html#how-to-run">How to Run</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../notes/introduction.html">Introduction by Example</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../notes/introduction.html#data-handling-of-graphs">Data Handling of Graphs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../notes/introduction.html#common-benchmark-datasets">Common Benchmark Datasets</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../notes/introduction.html#mini-batches">Mini-batches</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../notes/create_dataset.html">Creating Your Own Datasets</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../notes/create_dataset.html#creating-in-memory-datasets">Creating “In Memory Datasets”</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../notes/create_dataset.html#creating-larger-datasets">Creating “Larger” Datasets</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../notes/create_dataset.html#frequently-asked-questions">Frequently Asked Questions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../notes/create_dataset.html#exercises">Exercises</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../notes/create_gnn.html">Creating Message Passing Networks</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../notes/create_gnn.html#the-messagepassing-base-class">The “MessagePassing” Base Class</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../notes/create_gnn.html#implementing-the-gcn-layer">Implementing the GCN Layer</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../notes/create_gnn.html#implementing-the-edge-convolution">Implementing the Edge Convolution</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../notes/create_gnn.html#exercises">Exercises</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../notes/batching.html">Advanced Mini-Batching</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../notes/batching.html#pairs-of-graphs">Pairs of Graphs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../notes/batching.html#bipartite-graphs">Bipartite Graphs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../notes/batching.html#batching-along-new-dimensions">Batching Along New Dimensions</a></li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../api/gammagl.data.html">gammagl.data</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/gammagl.data.BaseGraph.html">gammagl.data.BaseGraph</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/gammagl.data.Graph.html">gammagl.data.Graph</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/gammagl.data.BatchGraph.html">gammagl.data.BatchGraph</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/gammagl.data.HeteroGraph.html">gammagl.data.HeteroGraph</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/gammagl.data.Dataset.html">gammagl.data.Dataset</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/gammagl.data.download_url.html">gammagl.data.download_url</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/gammagl.data.InMemoryDataset.html">gammagl.data.InMemoryDataset</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/gammagl.data.extract_zip.html">gammagl.data.extract_zip</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/gammagl.data.extract_tar.html">gammagl.data.extract_tar</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/gammagl.datasets.html">gammagl.datasets</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/gammagl.datasets.Amazon.html">gammagl.datasets.Amazon</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/gammagl.datasets.Coauthor.html">gammagl.datasets.Coauthor</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/gammagl.datasets.TUDataset.html">gammagl.datasets.TUDataset</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/gammagl.datasets.Planetoid.html">gammagl.datasets.Planetoid</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/gammagl.datasets.Reddit.html">gammagl.datasets.Reddit</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/gammagl.datasets.IMDB.html">gammagl.datasets.IMDB</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/gammagl.datasets.Entities.html">gammagl.datasets.Entities</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/gammagl.datasets.Flickr.html">gammagl.datasets.Flickr</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/gammagl.datasets.HGBDataset.html">gammagl.datasets.HGBDataset</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/gammagl.datasets.WikipediaNetwork.html">gammagl.datasets.WikipediaNetwork</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/gammagl.datasets.WebKB.html">gammagl.datasets.WebKB</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/gammagl.datasets.ModelNet40.html">gammagl.datasets.ModelNet40</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/gammagl.datasets.DBLP.html">gammagl.datasets.DBLP</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/gammagl.datasets.CA_GrQc.html">gammagl.datasets.CA_GrQc</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/gammagl.datasets.ZINC.html">gammagl.datasets.ZINC</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/gammagl.layers.html">gammagl.layers</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../api/gammagl.layers.html#convolutional-layers">Convolutional Layers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../api/gammagl.layers.html#pooling-layers">Pooling Layers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../api/gammagl.layers.html#model">Model</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/gammagl.loader.html">gammagl.loader</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/gammagl.loader.DataLoader.html">gammagl.loader.DataLoader</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/gammagl.loader.RandomWalk.html">gammagl.loader.RandomWalk</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/gammagl.transforms.html">gammagl.transforms</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/gammagl.transforms.BaseTransform.html">gammagl.transforms.BaseTransform</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/gammagl.transforms.AddMetaPaths.html">gammagl.transforms.AddMetaPaths</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/gammagl.transforms.Compose.html">gammagl.transforms.Compose</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/gammagl.transforms.SIGN.html">gammagl.transforms.SIGN</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/gammagl.transforms.NormalizeFeatures.html">gammagl.transforms.NormalizeFeatures</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/gammagl.transforms.DropEdge.html">gammagl.transforms.DropEdge</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/gammagl.transforms.RandomLinkSplit.html">gammagl.transforms.RandomLinkSplit</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/gammagl.transforms.mask_test_edges.html">gammagl.transforms.mask_test_edges</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/gammagl.transforms.sparse_to_tuple.html">gammagl.transforms.sparse_to_tuple</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/gammagl.utils.html">gammagl.utils</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/gammagl.utils.calc_A_norm_hat.html">gammagl.utils.calc_A_norm_hat</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/gammagl.utils.calc_gcn_norm.html">gammagl.utils.calc_gcn_norm</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/gammagl.utils.segment_softmax.html">gammagl.utils.segment_softmax</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/gammagl.utils.sort_edge_index.html">gammagl.utils.sort_edge_index</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/gammagl.utils.coalesce.html">gammagl.utils.coalesce</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/gammagl.utils.to_undirected.html">gammagl.utils.to_undirected</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/gammagl.utils.is_undirected.html">gammagl.utils.is_undirected</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/gammagl.utils.degree.html">gammagl.utils.degree</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/gammagl.utils.add_self_loops.html">gammagl.utils.add_self_loops</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/gammagl.utils.remove_self_loops.html">gammagl.utils.remove_self_loops</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/gammagl.utils.mask_to_index.html">gammagl.utils.mask_to_index</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/gammagl.utils.index_to_mask.html">gammagl.utils.index_to_mask</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/gammagl.utils.set_device.html">gammagl.utils.set_device</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/gammagl.utils.to_dense_batch.html">gammagl.utils.to_dense_batch</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/gammagl.utils.k_hop_subgraph.html">gammagl.utils.k_hop_subgraph</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/gammagl.utils.negative_sampling.html">gammagl.utils.negative_sampling</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/gammagl.utils.to_scipy_sparse_matrix.html">gammagl.utils.to_scipy_sparse_matrix</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/gammagl.utils.read_embeddings.html">gammagl.utils.read_embeddings</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../generated/gammagl.utils.homophily.html">gammagl.utils.homophily</a></li>
</ul>
</li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">GammaGL</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>gammagl.data.graph</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for gammagl.data.graph</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">tensorlayerx</span> <span class="k">as</span> <span class="nn">tlx</span>

<span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Mapping</span><span class="p">,</span> <span class="n">Sequence</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">Any</span><span class="p">,</span>
    <span class="n">Callable</span><span class="p">,</span>
    <span class="n">Dict</span><span class="p">,</span>
    <span class="n">Iterable</span><span class="p">,</span>
    <span class="n">List</span><span class="p">,</span>
    <span class="n">NamedTuple</span><span class="p">,</span>
    <span class="n">Optional</span><span class="p">,</span>
    <span class="n">Tuple</span><span class="p">,</span>
    <span class="n">Union</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">gammagl.data.storage</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">BaseStorage</span><span class="p">,</span>
    <span class="n">EdgeStorage</span><span class="p">,</span>
    <span class="n">GlobalStorage</span><span class="p">,</span>
    <span class="n">NodeStorage</span>
<span class="p">)</span>

<span class="kn">from</span> <span class="nn">gammagl.sparse.sparse_adj</span> <span class="kn">import</span> <span class="n">CSRAdj</span>
<span class="kn">from</span> <span class="nn">gammagl.utils.loop</span> <span class="kn">import</span> <span class="n">add_self_loops</span>
<span class="kn">from</span> <span class="nn">gammagl.utils.check</span> <span class="kn">import</span> <span class="n">check_is_numpy</span>
<span class="kn">from</span> <span class="nn">gammagl.typing</span> <span class="kn">import</span> <span class="n">NodeType</span><span class="p">,</span> <span class="n">EdgeType</span>


<div class="viewcode-block" id="BaseGraph"><a class="viewcode-back" href="../../../generated/gammagl.data.BaseGraph.html#gammagl.data.BaseGraph">[docs]</a><span class="k">class</span> <span class="nc">BaseGraph</span><span class="p">:</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="k">def</span> <span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">Any</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="k">def</span> <span class="fm">__delattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">Any</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="k">def</span> <span class="fm">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="k">def</span> <span class="nf">__copy__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="k">def</span> <span class="nf">__deepcopy__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memo</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="k">def</span> <span class="nf">stores_as</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="s1">&#39;BaseGraph&#39;</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">stores</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">BaseStorage</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">node_stores</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">NodeStorage</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">edge_stores</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">EdgeStorage</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

<div class="viewcode-block" id="BaseGraph.to_dict"><a class="viewcode-back" href="../../../generated/gammagl.data.BaseGraph.html#gammagl.data.BaseGraph.to_dict">[docs]</a>    <span class="k">def</span> <span class="nf">to_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Returns a dictionary of stored key/value pairs.&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span></div>

<div class="viewcode-block" id="BaseGraph.to_namedtuple"><a class="viewcode-back" href="../../../generated/gammagl.data.BaseGraph.html#gammagl.data.BaseGraph.to_namedtuple">[docs]</a>    <span class="k">def</span> <span class="nf">to_namedtuple</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NamedTuple</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Returns a :obj:`NamedTuple` of stored key/value pairs.&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span></div>

<div class="viewcode-block" id="BaseGraph.__cat_dim__"><a class="viewcode-back" href="../../../generated/gammagl.data.BaseGraph.html#gammagl.data.BaseGraph.__cat_dim__">[docs]</a>    <span class="k">def</span> <span class="nf">__cat_dim__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Returns the dimension for which the value :obj:`value` of the</span>
<span class="sd">        attribute :obj:`key` will get concatenated when creating mini-batches</span>
<span class="sd">        using :class:`gammagl.loader.DataLoader`.</span>

<span class="sd">        .. note::</span>
<span class="sd">            This method is for internal use only, and should only be overridden</span>
<span class="sd">            in case the mini-batch creation process is corrupted for a specific</span>
<span class="sd">            attribute.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span></div>

<div class="viewcode-block" id="BaseGraph.__inc__"><a class="viewcode-back" href="../../../generated/gammagl.data.BaseGraph.html#gammagl.data.BaseGraph.__inc__">[docs]</a>    <span class="k">def</span> <span class="nf">__inc__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Returns the incremental count to cumulatively increase the value</span>
<span class="sd">        :obj:`value` of the attribute :obj:`key` when creating mini-batches</span>
<span class="sd">        using :class:`gammagl.loader.DataLoader`.</span>

<span class="sd">        .. note::</span>
<span class="sd">            This method is for internal use only, and should only be overridden</span>
<span class="sd">            in case the mini-batch creation process is corrupted for a specific</span>
<span class="sd">            attribute.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span></div>

    <span class="k">def</span> <span class="nf">debug</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="c1">###########################################################################</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">keys</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Returns a list of all graph attribute names.&quot;&quot;&quot;</span>
        <span class="n">out</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">store</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">stores</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">+=</span> <span class="nb">list</span><span class="p">(</span><span class="n">store</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">out</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Returns the number of graph attributes.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Returns :obj:`True` if the attribute :obj:`key` is present in the</span>
<span class="sd">        data.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span>

    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
        <span class="c1"># func `__getstate__` solve the problem of pickle Graph</span>
        <span class="c1"># https://stackoverflow.com/questions/50156118/recursionerror-maximum-recursion-depth-exceeded-while-calling-a-python-object-w</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span>

    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mapping</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]):</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">mapping</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">num_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Returns the number of nodes in the graph.</span>

<span class="sd">        .. note::</span>
<span class="sd">            The number of nodes in the data object is automatically inferred</span>
<span class="sd">            in case node-level attributes are present, *e.g.*, :obj:`data.x`.</span>
<span class="sd">            In some cases, however, a graph may only be given without any</span>
<span class="sd">            node-level attributes.</span>
<span class="sd">            GammaGL then *guesses* the number of nodes according to</span>
<span class="sd">            :obj:`edge_index.max().item() + 1`.</span>
<span class="sd">            However, in case there exists isolated nodes, this number does not</span>
<span class="sd">            have to be correct which can result in unexpected behaviour.</span>
<span class="sd">            Thus, we recommend to set the number of nodes in your data object</span>
<span class="sd">            explicitly via :obj:`graph.num_nodes = ...`.</span>
<span class="sd">            You will be given a warning that requests you to do so.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">sum</span><span class="p">([</span><span class="n">v</span><span class="o">.</span><span class="n">num_nodes</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_stores</span><span class="p">])</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

<div class="viewcode-block" id="BaseGraph.size"><a class="viewcode-back" href="../../../generated/gammagl.data.BaseGraph.html#gammagl.data.BaseGraph.size">[docs]</a>    <span class="k">def</span> <span class="nf">size</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Returns the size of the adjacency matrix induced by the graph.&quot;&quot;&quot;</span>
        <span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_nodes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_nodes</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">size</span> <span class="k">if</span> <span class="n">dim</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">size</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">num_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Returns the number of edges in the graph.</span>
<span class="sd">        For undirected graphs, this will return the number of bi-directional</span>
<span class="sd">        edges, which is double the amount of unique edges.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">([</span><span class="n">v</span><span class="o">.</span><span class="n">num_edges</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge_stores</span><span class="p">])</span>

<div class="viewcode-block" id="BaseGraph.is_coalesced"><a class="viewcode-back" href="../../../generated/gammagl.data.BaseGraph.html#gammagl.data.BaseGraph.is_coalesced">[docs]</a>    <span class="k">def</span> <span class="nf">is_coalesced</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Returns :obj:`True` if edge indices :obj:`edge_index` are sorted</span>
<span class="sd">        and do not contain duplicate entries.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">all</span><span class="p">([</span><span class="n">store</span><span class="o">.</span><span class="n">is_coalesced</span><span class="p">()</span> <span class="k">for</span> <span class="n">store</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge_stores</span><span class="p">])</span></div>

<div class="viewcode-block" id="BaseGraph.coalesce"><a class="viewcode-back" href="../../../generated/gammagl.data.BaseGraph.html#gammagl.data.BaseGraph.coalesce">[docs]</a>    <span class="k">def</span> <span class="nf">coalesce</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Sorts and removes duplicated entries from edge indices</span>
<span class="sd">        :obj:`edge_index`.&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">store</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge_stores</span><span class="p">:</span>
            <span class="n">store</span><span class="o">.</span><span class="n">coalesce</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="BaseGraph.has_isolated_nodes"><a class="viewcode-back" href="../../../generated/gammagl.data.BaseGraph.html#gammagl.data.BaseGraph.has_isolated_nodes">[docs]</a>    <span class="k">def</span> <span class="nf">has_isolated_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Returns :obj:`True` if the graph contains isolated nodes.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">any</span><span class="p">([</span><span class="n">store</span><span class="o">.</span><span class="n">has_isolated_nodes</span><span class="p">()</span> <span class="k">for</span> <span class="n">store</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge_stores</span><span class="p">])</span></div>

<div class="viewcode-block" id="BaseGraph.has_self_loops"><a class="viewcode-back" href="../../../generated/gammagl.data.BaseGraph.html#gammagl.data.BaseGraph.has_self_loops">[docs]</a>    <span class="k">def</span> <span class="nf">has_self_loops</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns :obj:`True` if the graph contains self-loops.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">any</span><span class="p">([</span><span class="n">store</span><span class="o">.</span><span class="n">has_self_loops</span><span class="p">()</span> <span class="k">for</span> <span class="n">store</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge_stores</span><span class="p">])</span></div>

    <span class="c1"># The Graph is directed in GammaGL.</span>

<div class="viewcode-block" id="BaseGraph.is_undirected"><a class="viewcode-back" href="../../../generated/gammagl.data.BaseGraph.html#gammagl.data.BaseGraph.is_undirected">[docs]</a>    <span class="k">def</span> <span class="nf">is_undirected</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Returns :obj:`True` if graph edges are undirected.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">all</span><span class="p">([</span><span class="n">store</span><span class="o">.</span><span class="n">is_undirected</span><span class="p">()</span> <span class="k">for</span> <span class="n">store</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge_stores</span><span class="p">])</span></div>

<div class="viewcode-block" id="BaseGraph.is_directed"><a class="viewcode-back" href="../../../generated/gammagl.data.BaseGraph.html#gammagl.data.BaseGraph.is_directed">[docs]</a>    <span class="k">def</span> <span class="nf">is_directed</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Returns :obj:`True` if graph edges are directed.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_undirected</span><span class="p">()</span></div>

<div class="viewcode-block" id="BaseGraph.apply_"><a class="viewcode-back" href="../../../generated/gammagl.data.BaseGraph.html#gammagl.data.BaseGraph.apply_">[docs]</a>    <span class="k">def</span> <span class="nf">apply_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Applies the in-place function :obj:`func`, either to all attributes</span>
<span class="sd">        or only the ones given in :obj:`*args`.&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">store</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">stores</span><span class="p">:</span>
            <span class="n">store</span><span class="o">.</span><span class="n">apply_</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="BaseGraph.apply"><a class="viewcode-back" href="../../../generated/gammagl.data.BaseGraph.html#gammagl.data.BaseGraph.apply">[docs]</a>    <span class="k">def</span> <span class="nf">apply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Applies the function :obj:`func`, either to all attributes or only</span>
<span class="sd">        the ones given in :obj:`*args`.&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">store</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">stores</span><span class="p">:</span>
            <span class="n">store</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="BaseGraph.clone"><a class="viewcode-back" href="../../../generated/gammagl.data.BaseGraph.html#gammagl.data.BaseGraph.clone">[docs]</a>    <span class="k">def</span> <span class="nf">clone</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Performs cloning of tensors, either for all attributes or only the</span>
<span class="sd">        ones given in :obj:`*args`.</span>
<span class="sd">        It can only be used in Torch.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">clone</span><span class="p">(),</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_apply_to_tensor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">value</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">CSRAdj</span><span class="p">):</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">)</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">value</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">value</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">tlx</span><span class="o">.</span><span class="n">convert_to_tensor</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">new_value</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">value</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">new_value</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">tlx</span><span class="o">.</span><span class="n">convert_to_tensor</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">new_value</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">tlx</span><span class="o">.</span><span class="n">is_tensor</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
                <span class="k">pass</span>
            <span class="k">elif</span> <span class="n">check_is_numpy</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;edge_index&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="s1">&#39;edge_type&#39;</span><span class="p">,</span> <span class="s1">&#39;train_idx&#39;</span><span class="p">,</span> <span class="s1">&#39;test_idx&#39;</span><span class="p">,</span> <span class="s1">&#39;train_y&#39;</span><span class="p">]:</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="n">tlx</span><span class="o">.</span><span class="n">convert_to_tensor</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tlx</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;train_mask&#39;</span><span class="p">,</span> <span class="s1">&#39;val_mask&#39;</span><span class="p">,</span> <span class="s1">&#39;test_mask&#39;</span><span class="p">,</span> <span class="p">]:</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="n">tlx</span><span class="o">.</span><span class="n">convert_to_tensor</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tlx</span><span class="o">.</span><span class="n">bool</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="n">tlx</span><span class="o">.</span><span class="n">convert_to_tensor</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tlx</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">value</span>

    <span class="k">def</span> <span class="nf">_apply_to_numpy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">value</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">CSRAdj</span><span class="p">):</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">numpy</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">value</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">value</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">new_value</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">value</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">new_value</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">new_value</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">check_is_numpy</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
                <span class="k">pass</span>
            <span class="k">elif</span> <span class="n">tlx</span><span class="o">.</span><span class="n">is_tensor</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
                <span class="c1"># can&#39;t assign type of numpy</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">tlx</span><span class="o">.</span><span class="n">convert_to_numpy</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">value</span></div>


<span class="c1"># def contiguous(self, *args: List[str]):</span>
<span class="c1"># 	r&quot;&quot;&quot;Ensures a contiguous memory layout, either for all attributes or</span>
<span class="c1"># 	only the ones given in :obj:`*args`.&quot;&quot;&quot;</span>
<span class="c1"># 	return self.apply(lambda x: x.contiguous(), *args)</span>
<span class="c1">#</span>
<span class="c1"># def to(self, device: Union[int, str], *args: List[str],</span>
<span class="c1"># 	   non_blocking: bool = False):</span>
<span class="c1"># 	r&quot;&quot;&quot;Performs tensor device conversion, either for all attributes or</span>
<span class="c1"># 	only the ones given in :obj:`*args`.&quot;&quot;&quot;</span>
<span class="c1"># 	return self.apply(</span>
<span class="c1"># 		lambda x: x.to(device=device, non_blocking=non_blocking), *args)</span>
<span class="c1">#</span>
<span class="c1"># def cpu(self, *args: List[str]):</span>
<span class="c1"># 	r&quot;&quot;&quot;Copies attributes to CPU memory, either for all attributes or only</span>
<span class="c1"># 	the ones given in :obj:`*args`.&quot;&quot;&quot;</span>
<span class="c1"># 	return self.apply(lambda x: x.cpu(), *args)</span>
<span class="c1">#</span>
<span class="c1"># def cuda(self, device: Optional[Union[int, str]] = None, *args: List[str],</span>
<span class="c1"># 		 non_blocking: bool = False):</span>
<span class="c1"># 	r&quot;&quot;&quot;Copies attributes to CUDA memory, either for all attributes or only</span>
<span class="c1"># 	the ones given in :obj:`*args`.&quot;&quot;&quot;</span>
<span class="c1"># 	# Some PyTorch tensor like objects require a default value for `cuda`:</span>
<span class="c1"># 	device = &#39;cuda&#39; if device is None else device</span>
<span class="c1"># 	return self.apply(lambda x: x.cuda(device, non_blocking=non_blocking),</span>
<span class="c1"># 					  *args)</span>
<span class="c1">#</span>
<span class="c1"># def pin_memory(self, *args: List[str]):</span>
<span class="c1"># 	r&quot;&quot;&quot;Copies attributes to pinned memory, either for all attributes or</span>
<span class="c1"># 	only the ones given in :obj:`*args`.&quot;&quot;&quot;</span>
<span class="c1"># 	return self.apply(lambda x: x.pin_memory(), *args)</span>
<span class="c1">#</span>
<span class="c1"># def share_memory_(self, *args: List[str]):</span>
<span class="c1"># 	r&quot;&quot;&quot;Moves attributes to shared memory, either for all attributes or</span>
<span class="c1"># 	only the ones given in :obj:`*args`.&quot;&quot;&quot;</span>
<span class="c1"># 	return self.apply_(lambda x: x.share_memory_(), *args)</span>
<span class="c1">#</span>
<span class="c1"># def detach_(self, *args: List[str]):</span>
<span class="c1"># 	r&quot;&quot;&quot;Detaches attributes from the computation graph, either for all</span>
<span class="c1"># 	attributes or only the ones given in :obj:`*args`.&quot;&quot;&quot;</span>
<span class="c1"># 	return self.apply_(lambda x: x.detach_(), *args)</span>
<span class="c1">#</span>
<span class="c1"># def detach(self, *args: List[str]):</span>
<span class="c1"># 	r&quot;&quot;&quot;Detaches attributes from the computation graph by creating a new</span>
<span class="c1"># 	tensor, either for all attributes or only the ones given in</span>
<span class="c1"># 	:obj:`*args`.&quot;&quot;&quot;</span>
<span class="c1"># 	return self.apply(lambda x: x.detach(), *args)</span>
<span class="c1">#</span>
<span class="c1"># def requires_grad_(self, *args: List[str], requires_grad: bool = True):</span>
<span class="c1"># 	r&quot;&quot;&quot;Tracks gradient computation, either for all attributes or only the</span>
<span class="c1"># 	ones given in :obj:`*args`.&quot;&quot;&quot;</span>
<span class="c1"># 	return self.apply_(</span>
<span class="c1"># 		lambda x: x.requires_grad_(requires_grad=requires_grad), *args)</span>
<span class="c1">#</span>
<span class="c1"># def record_stream(self, stream: torch.cuda.Stream, *args: List[str]):</span>
<span class="c1"># 	r&quot;&quot;&quot;Ensures that the tensor memory is not reused for another tensor</span>
<span class="c1"># 	until all current work queued on :obj:`stream` has been completed,</span>
<span class="c1"># 	either for all attributes or only the ones given in :obj:`*args`.&quot;&quot;&quot;</span>
<span class="c1"># 	return self.apply_(lambda x: x.record_stream(stream), *args)</span>
<span class="c1">#</span>
<span class="c1"># @property</span>
<span class="c1"># def is_cuda(self) -&gt; bool:</span>
<span class="c1"># 	r&quot;&quot;&quot;Returns :obj:`True` if any :class:`torch.Tensor` attribute is</span>
<span class="c1"># 	stored on the GPU, :obj:`False` otherwise.&quot;&quot;&quot;</span>
<span class="c1"># 	for store in self.stores:</span>
<span class="c1"># 		for value in store.values():</span>
<span class="c1"># 			if isinstance(value, Tensor) and value.is_cuda:</span>
<span class="c1"># 				return True</span>
<span class="c1"># 	return False</span>


<div class="viewcode-block" id="Graph"><a class="viewcode-back" href="../../../generated/gammagl.data.Graph.html#gammagl.data.Graph">[docs]</a><span class="k">class</span> <span class="nc">Graph</span><span class="p">(</span><span class="n">BaseGraph</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A Graph object describe a homogeneous graph. The graph object</span>
<span class="sd">    will hold node-level, link-level and graph-level attributes. In</span>
<span class="sd">    general, :class:`~gammagl.data.Data` tries to mimic the behaviour</span>
<span class="sd">    of a regular Python dictionary. In addition, it provides useful</span>
<span class="sd">    functionality for analyzing graph structures, and provides basic</span>
<span class="sd">    tensor functionalities.</span>

<span class="sd">    .. code:: python</span>

<span class="sd">        &gt;&gt;&gt; from gammagl.data import Graph</span>
<span class="sd">        &gt;&gt;&gt; import numpy</span>
<span class="sd">        &gt;&gt;&gt; g = graph.Graph(x=numpy.random.randn(5, 16), edge_index=[[0, 0, 0], [1, 2, 3]], num_nodes=5,)</span>
<span class="sd">        &gt;&gt;&gt; print(g)</span>
<span class="sd">        GNN Graph instance.</span>
<span class="sd">        number of nodes: 5</span>
<span class="sd">        number of edges: 2</span>

<span class="sd">        &gt;&gt;&gt; print(g.indegree.numpy(), g.outdegree.numpy())</span>
<span class="sd">        [0. 1. 1. 1. 0.] [3. 0. 0. 0. 0.]</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x: Tensor</span>
<span class="sd">        Node feature matrix with shape :obj:`[num_nodes, num_node_features]`. (default: :obj:`None`)</span>
<span class="sd">    edge_index: LongTensor</span>
<span class="sd">        Graph connectivity in COO format with shape :obj:`[2, num_edges]`. (default: :obj:`None`)</span>
<span class="sd">    edge_attr: Tensor</span>
<span class="sd">        Edge feature matrix with shape :obj:`[num_edges, num_edge_features]`. (default: :obj:`None`)</span>
<span class="sd">    num_nodes: int</span>
<span class="sd">        The specified number of nodes. (default: :obj:`None`)</span>
<span class="sd">    y: Tensor</span>
<span class="sd">        Graph-level or node-level ground-truth labels with arbitrary shape. (default: :obj:`None`)</span>
<span class="sd">    to_tensor: Bool</span>
<span class="sd">        Set data to tensor</span>
<span class="sd">    spr_format: List(str)</span>
<span class="sd">        Specify the other sparse storage format, like `csc` and `csr`. (default: :obj:`None`)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">edge_index</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">edge_attr</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">spr_format</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">to_tensor</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="s1">&#39;_store&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">GlobalStorage</span><span class="p">(</span><span class="n">_parent</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">edge_index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">edge_index</span> <span class="o">=</span> <span class="n">edge_index</span>
        <span class="k">if</span> <span class="n">edge_attr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">edge_attr</span> <span class="o">=</span> <span class="n">edge_attr</span>
        <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span>
        <span class="k">if</span> <span class="n">y</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">y</span>
        <span class="c1"># self.num_nodes = num_nodes</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">to_tensor</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tensor</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">spr_format</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="s1">&#39;csr&#39;</span> <span class="ow">in</span> <span class="n">spr_format</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">csr_adj</span> <span class="o">=</span> <span class="n">CSRAdj</span><span class="o">.</span><span class="n">from_edges</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edge_index</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge_index</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_nodes</span><span class="p">)</span>
            <span class="k">if</span> <span class="s1">&#39;csc&#39;</span> <span class="ow">in</span> <span class="n">spr_format</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">csc_adj</span> <span class="o">=</span> <span class="n">CSRAdj</span><span class="o">.</span><span class="n">from_edges</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edge_index</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge_index</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_nodes</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
        <span class="c1"># Called when the default attribute access fails, which means getattr</span>
        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_store</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">Any</span><span class="p">):</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_store</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__delattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="nb">delattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_store</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_store</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">Any</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_store</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span> <span class="fm">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_store</span><span class="p">:</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_store</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">__copy__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">out</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
        <span class="n">out</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="s1">&#39;_store&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_store</span><span class="p">)</span>
        <span class="n">out</span><span class="o">.</span><span class="n">_store</span><span class="o">.</span><span class="n">_parent</span> <span class="o">=</span> <span class="n">out</span>
        <span class="k">return</span> <span class="n">out</span>

    <span class="k">def</span> <span class="nf">__deepcopy__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memo</span><span class="p">):</span>
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">out</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">memo</span><span class="p">)</span>
        <span class="n">out</span><span class="o">.</span><span class="n">_store</span><span class="o">.</span><span class="n">_parent</span> <span class="o">=</span> <span class="n">out</span>
        <span class="k">return</span> <span class="n">out</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="bp">cls</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="n">has_dict</span> <span class="o">=</span> <span class="nb">any</span><span class="p">([</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">Mapping</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_store</span><span class="o">.</span><span class="n">values</span><span class="p">()])</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">has_dict</span><span class="p">:</span>
            <span class="n">info</span> <span class="o">=</span> <span class="p">[</span><span class="n">size_repr</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_store</span><span class="o">.</span><span class="n">items</span><span class="p">()]</span>
            <span class="n">info</span> <span class="o">=</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">info</span><span class="p">)</span>
            <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">cls</span><span class="si">}</span><span class="s1">(</span><span class="si">{</span><span class="n">info</span><span class="si">}</span><span class="s1">)&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">info</span> <span class="o">=</span> <span class="p">[</span><span class="n">size_repr</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">indent</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_store</span><span class="o">.</span><span class="n">items</span><span class="p">()]</span>
            <span class="n">info</span> <span class="o">=</span> <span class="s1">&#39;,</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">info</span><span class="p">)</span>
            <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">cls</span><span class="si">}</span><span class="s1">(</span><span class="se">\n</span><span class="si">{</span><span class="n">info</span><span class="si">}</span><span class="se">\n</span><span class="s1">)&#39;</span>

    <span class="k">def</span> <span class="nf">stores_as</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="s1">&#39;Data&#39;</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">stores</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">BaseStorage</span><span class="p">]:</span>
        <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_store</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">node_stores</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">NodeStorage</span><span class="p">]:</span>
        <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_store</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">edge_stores</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">EdgeStorage</span><span class="p">]:</span>
        <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_store</span><span class="p">]</span>

<div class="viewcode-block" id="Graph.to_dict"><a class="viewcode-back" href="../../../generated/gammagl.data.Graph.html#gammagl.data.Graph.to_dict">[docs]</a>    <span class="k">def</span> <span class="nf">to_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_store</span><span class="o">.</span><span class="n">to_dict</span><span class="p">()</span></div>

<div class="viewcode-block" id="Graph.to_namedtuple"><a class="viewcode-back" href="../../../generated/gammagl.data.Graph.html#gammagl.data.Graph.to_namedtuple">[docs]</a>    <span class="k">def</span> <span class="nf">to_namedtuple</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NamedTuple</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_store</span><span class="o">.</span><span class="n">to_namedtuple</span><span class="p">()</span></div>

<div class="viewcode-block" id="Graph.__cat_dim__"><a class="viewcode-back" href="../../../generated/gammagl.data.Graph.html#gammagl.data.Graph.__cat_dim__">[docs]</a>    <span class="k">def</span> <span class="nf">__cat_dim__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
        <span class="c1"># if isinstance(value, SparseTensor) and &#39;adj&#39; in key:</span>
        <span class="c1"># 	return (0, 1)</span>
        <span class="k">if</span> <span class="s1">&#39;index&#39;</span> <span class="ow">in</span> <span class="n">key</span> <span class="ow">or</span> <span class="n">key</span> <span class="o">==</span> <span class="s1">&#39;face&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span></div>

<div class="viewcode-block" id="Graph.__inc__"><a class="viewcode-back" href="../../../generated/gammagl.data.Graph.html#gammagl.data.Graph.__inc__">[docs]</a>    <span class="k">def</span> <span class="nf">__inc__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
        <span class="k">if</span> <span class="s1">&#39;batch&#39;</span> <span class="ow">in</span> <span class="n">key</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">tlx</span><span class="o">.</span><span class="n">reduce_max</span><span class="p">(</span><span class="n">value</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="s1">&#39;index&#39;</span> <span class="ow">in</span> <span class="n">key</span> <span class="ow">or</span> <span class="n">key</span> <span class="o">==</span> <span class="s1">&#39;face&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_nodes</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span></div>

    <span class="k">def</span> <span class="nf">debug</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>  <span class="c1"># TODO</span>

<div class="viewcode-block" id="Graph.is_node_attr"><a class="viewcode-back" href="../../../generated/gammagl.data.Graph.html#gammagl.data.Graph.is_node_attr">[docs]</a>    <span class="k">def</span> <span class="nf">is_node_attr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Returns :obj:`True` if the object at key :obj:`key` denotes a</span>
<span class="sd">        node-level attribute.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_store</span><span class="o">.</span><span class="n">is_node_attr</span><span class="p">(</span><span class="n">key</span><span class="p">)</span></div>

<div class="viewcode-block" id="Graph.is_edge_attr"><a class="viewcode-back" href="../../../generated/gammagl.data.Graph.html#gammagl.data.Graph.is_edge_attr">[docs]</a>    <span class="k">def</span> <span class="nf">is_edge_attr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Returns :obj:`True` if the object at key :obj:`key` denotes an</span>
<span class="sd">        edge-level attribute.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_store</span><span class="o">.</span><span class="n">is_edge_attr</span><span class="p">(</span><span class="n">key</span><span class="p">)</span></div>

    <span class="c1">#</span>
    <span class="c1"># def subgraph(self, subset: Tensor):</span>
    <span class="c1"># 	r&quot;&quot;&quot;Returns the induced subgraph given by the node indices</span>
    <span class="c1"># 	:obj:`subset`.</span>
    <span class="c1"># 	Args:</span>
    <span class="c1"># 		subset (LongTensor or BoolTensor): The nodes to keep.</span>
    <span class="c1"># 	&quot;&quot;&quot;</span>
    <span class="c1">#</span>
    <span class="c1"># 	out = subgraph(subset, self.edge_index, relabel_nodes=True,</span>
    <span class="c1"># 				   num_nodes=self.num_nodes, return_edge_mask=True)</span>
    <span class="c1"># 	edge_index, _, edge_mask = out</span>
    <span class="c1">#</span>
    <span class="c1"># 	if subset.dtype == torch.bool:</span>
    <span class="c1"># 		num_nodes = int(subset.sum())</span>
    <span class="c1"># 	else:</span>
    <span class="c1"># 		num_nodes = subset.size(0)</span>
    <span class="c1">#</span>
    <span class="c1"># 	data = copy.copy(self)</span>
    <span class="c1">#</span>
    <span class="c1"># 	for key, value in data:</span>
    <span class="c1"># 		if key == &#39;edge_index&#39;:</span>
    <span class="c1"># 			data.edge_index = edge_index</span>
    <span class="c1"># 		elif key == &#39;num_nodes&#39;:</span>
    <span class="c1"># 			data.num_nodes = num_nodes</span>
    <span class="c1"># 		elif isinstance(value, Tensor):</span>
    <span class="c1"># 			if self.is_node_attr(key):</span>
    <span class="c1"># 				data[key] = value[subset]</span>
    <span class="c1"># 			elif self.is_edge_attr(key):</span>
    <span class="c1"># 				data[key] = value[edge_mask]</span>
    <span class="c1">#</span>
    <span class="c1"># 	return data</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">in_degree</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Graph property, return the node in-degree of the graph.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;csc_adj&#39;</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">csc_adj</span><span class="o">.</span><span class="n">degree</span>
        <span class="k">return</span> <span class="n">tlx</span><span class="o">.</span><span class="n">unsorted_segment_sum</span><span class="p">(</span><span class="n">tlx</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edge_index</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tlx</span><span class="o">.</span><span class="n">int64</span><span class="p">),</span>
                                        <span class="bp">self</span><span class="o">.</span><span class="n">edge_index</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_nodes</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">out_degree</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Graph property, return the node out-degree of the graph.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;csr_adj&#39;</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">csr_adj</span><span class="o">.</span><span class="n">degree</span>
        <span class="k">return</span> <span class="n">tlx</span><span class="o">.</span><span class="n">unsorted_segment_sum</span><span class="p">(</span><span class="n">tlx</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edge_index</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tlx</span><span class="o">.</span><span class="n">int64</span><span class="p">),</span>
                                        <span class="bp">self</span><span class="o">.</span><span class="n">edge_index</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_nodes</span><span class="p">)</span>

<div class="viewcode-block" id="Graph.add_self_loop"><a class="viewcode-back" href="../../../generated/gammagl.data.Graph.html#gammagl.data.Graph.add_self_loop">[docs]</a>    <span class="k">def</span> <span class="nf">add_self_loop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_loops</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        n_loops: int</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        edge_index: Tensor</span>
<span class="sd">            original edges with self loop edges.</span>
<span class="sd">        edge_attr: FloatTensor</span>
<span class="sd">            attributes of edges.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">add_self_loops</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edge_index</span><span class="p">,</span> <span class="n">n_loops</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge_attr</span><span class="p">,</span> <span class="n">num_nodes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">num_nodes</span><span class="p">)</span></div>

<div class="viewcode-block" id="Graph.sorted_edges"><a class="viewcode-back" href="../../../generated/gammagl.data.Graph.html#gammagl.data.Graph.sorted_edges">[docs]</a>    <span class="k">def</span> <span class="nf">sorted_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sort_by</span><span class="o">=</span><span class="s2">&quot;src&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return sorted edges with different strategies.</span>
<span class="sd">        This function will return sorted edges with different strategy.</span>
<span class="sd">        If :code:`sort_by=&quot;src&quot;`, then edges will be sorted by :code:`src`</span>
<span class="sd">        nodes and otherwise :code:`dst`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sort_by: str</span>
<span class="sd">            The type for sorted edges. (&quot;src&quot; or &quot;dst&quot;)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tuple</span>
<span class="sd">            A tuple of (sorted_src, sorted_dst, sorted_eid).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">sort_by</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;src&quot;</span><span class="p">,</span> <span class="s2">&quot;dst&quot;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;sort_by should be in &#39;src&#39; or &#39;dst&#39;.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">sort_by</span> <span class="o">==</span> <span class="s1">&#39;src&#39;</span><span class="p">:</span>
            <span class="n">src</span><span class="p">,</span> <span class="n">dst</span><span class="p">,</span> <span class="n">eid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_csr_adj</span><span class="o">.</span><span class="n">triples</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dst</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">eid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_csc_adj</span><span class="o">.</span><span class="n">triples</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">src</span><span class="p">,</span> <span class="n">dst</span><span class="p">,</span> <span class="n">eid</span></div>

<div class="viewcode-block" id="Graph.tensor"><a class="viewcode-back" href="../../../generated/gammagl.data.Graph.html#gammagl.data.Graph.tensor">[docs]</a>    <span class="k">def</span> <span class="nf">tensor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert the Graph into paddle.Tensor format.</span>
<span class="sd">        In paddle.Tensor format, the graph edges and node features are in paddle.Tensor format.</span>
<span class="sd">        You can use send and recv in paddle.Tensor graph.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        inplace: bool</span>
<span class="sd">            (Default True) Whether to convert the graph into tensor inplace.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_store</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_store</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_to_tensor</span><span class="p">(</span>
                    <span class="n">key</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_store</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">inplace</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_dict</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">:</span>
                <span class="n">new_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_to_tensor</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">key</span><span class="p">],</span>
                                                      <span class="n">inplace</span><span class="p">)</span>

            <span class="n">graph</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span>
                <span class="n">num_nodes</span><span class="o">=</span><span class="n">new_dict</span><span class="p">[</span><span class="s2">&quot;_num_nodes&quot;</span><span class="p">],</span>
                <span class="n">edges</span><span class="o">=</span><span class="n">new_dict</span><span class="p">[</span><span class="s2">&quot;_edges&quot;</span><span class="p">],</span>
                <span class="n">x</span><span class="o">=</span><span class="n">new_dict</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">],</span>
                <span class="n">edge_attr</span><span class="o">=</span><span class="n">new_dict</span><span class="p">[</span><span class="s2">&quot;edge_attr&quot;</span><span class="p">],</span>
                <span class="n">adj_src_index</span><span class="o">=</span><span class="n">new_dict</span><span class="p">[</span><span class="s2">&quot;_adj_src_index&quot;</span><span class="p">],</span>
                <span class="n">adj_dst_index</span><span class="o">=</span><span class="n">new_dict</span><span class="p">[</span><span class="s2">&quot;_adj_dst_index&quot;</span><span class="p">],</span>
                <span class="o">**</span><span class="n">new_dict</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">graph</span></div>

<div class="viewcode-block" id="Graph.numpy"><a class="viewcode-back" href="../../../generated/gammagl.data.Graph.html#gammagl.data.Graph.numpy">[docs]</a>    <span class="k">def</span> <span class="nf">numpy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert the Graph into numpy format.</span>
<span class="sd">        In numpy format, the graph edges and node features are in numpy.ndarray format.</span>
<span class="sd">        But you can&#39;t use send and recv in numpy graph.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        inplace: bool</span>
<span class="sd">            (Default True) Whether to convert the graph into numpy inplace.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>

            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_store</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_store</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_to_numpy</span><span class="p">(</span>
                    <span class="n">key</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_store</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">inplace</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_dict</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">:</span>
                <span class="n">new_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_to_numpy</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">key</span><span class="p">],</span>
                                                     <span class="n">inplace</span><span class="p">)</span>

            <span class="n">graph</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span>
                <span class="n">num_nodes</span><span class="o">=</span><span class="n">new_dict</span><span class="p">[</span><span class="s2">&quot;_num_nodes&quot;</span><span class="p">],</span>
                <span class="n">edges</span><span class="o">=</span><span class="n">new_dict</span><span class="p">[</span><span class="s2">&quot;_edges&quot;</span><span class="p">],</span>
                <span class="n">node_feat</span><span class="o">=</span><span class="n">new_dict</span><span class="p">[</span><span class="s2">&quot;_node_feat&quot;</span><span class="p">],</span>
                <span class="n">edge_attr</span><span class="o">=</span><span class="n">new_dict</span><span class="p">[</span><span class="s2">&quot;edge_attr&quot;</span><span class="p">],</span>
                <span class="n">adj_src_index</span><span class="o">=</span><span class="n">new_dict</span><span class="p">[</span><span class="s2">&quot;_adj_src_index&quot;</span><span class="p">],</span>
                <span class="n">adj_dst_index</span><span class="o">=</span><span class="n">new_dict</span><span class="p">[</span><span class="s2">&quot;_adj_dst_index&quot;</span><span class="p">],</span>
                <span class="o">**</span><span class="n">new_dict</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">graph</span></div>

<div class="viewcode-block" id="Graph.to_heterogeneous"><a class="viewcode-back" href="../../../generated/gammagl.data.Graph.html#gammagl.data.Graph.to_heterogeneous">[docs]</a>    <span class="k">def</span> <span class="nf">to_heterogeneous</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                         <span class="n">edge_type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                         <span class="n">node_type_names</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">NodeType</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                         <span class="n">edge_type_names</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">EdgeType</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="c1"># (self, node_type: Optional[Tensor] = None,</span>
        <span class="c1"># edge_type: Optional[Tensor] = None,</span>
        <span class="c1"># node_type_names: Optional[List[NodeType]] = None,</span>
        <span class="c1"># edge_type_names: Optional[List[EdgeType]] = None):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Converts a :class:`~gammagl.data.Graph` object to a</span>
<span class="sd">        heterogeneous :class:`~gammagl.data.HeteroGraph` object.</span>
<span class="sd">        For this, node and edge attributes are splitted according to the</span>
<span class="sd">        node-level and edge-level vectors :obj:`node_type` and</span>
<span class="sd">        :obj:`edge_type`, respectively.</span>
<span class="sd">        :obj:`node_type_names` and :obj:`edge_type_names` can be used to give</span>
<span class="sd">        meaningful node and edge type names, respectively.</span>
<span class="sd">        That is, the node_type :obj:`0` is given by :obj:`node_type_names[0]`.</span>
<span class="sd">        If the :class:`~gammagl.data.Graph` object was constructed via</span>
<span class="sd">        :meth:`~gammagl.data.HeteroGraph.to_homogeneous`, the object can</span>
<span class="sd">        be reconstructed without any need to pass in additional arguments.</span>

<span class="sd">        Args:</span>
<span class="sd">            node_type (Tensor, optional): A node-level vector denoting the type</span>
<span class="sd">                of each node. (default: :obj:`None`)</span>
<span class="sd">            edge_type (Tensor, optional): An edge-level vector denoting the</span>
<span class="sd">                type of each edge. (default: :obj:`None`)</span>
<span class="sd">            node_type_names (List[str], optional): The names of node types.</span>
<span class="sd">                (default: :obj:`None`)</span>
<span class="sd">            edge_type_names (List[Tuple[str, str, str]], optional): The names</span>
<span class="sd">                of edge types. (default: :obj:`None`)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">gammagl.data</span> <span class="kn">import</span> <span class="n">HeteroGraph</span>

        <span class="k">if</span> <span class="n">node_type</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">node_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_store</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;node_type&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">node_type</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">node_type</span> <span class="o">=</span> <span class="n">tlx</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_nodes</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tlx</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">node_type_names</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">store</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_store</span>
            <span class="n">node_type_names</span> <span class="o">=</span> <span class="n">store</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;_node_type_names&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">node_type_names</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">node_type_names</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">tlx</span><span class="o">.</span><span class="n">convert_to_numpy</span><span class="p">(</span><span class="n">node_type</span><span class="p">))</span><span class="o">.</span><span class="n">tolist</span><span class="p">()]</span>

        <span class="k">if</span> <span class="n">edge_type</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">edge_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_store</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;edge_type&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">edge_type</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">edge_type</span> <span class="o">=</span> <span class="n">tlx</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_edges</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tlx</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">edge_type_names</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">store</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_store</span>
            <span class="n">edge_type_names</span> <span class="o">=</span> <span class="n">store</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;_edge_type_names&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">edge_type_names</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">edge_type_names</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">edge_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge_index</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">tlx</span><span class="o">.</span><span class="n">convert_to_numpy</span><span class="p">(</span><span class="n">edge_type</span><span class="p">))</span><span class="o">.</span><span class="n">tolist</span><span class="p">():</span>
                <span class="n">src</span><span class="p">,</span> <span class="n">dst</span> <span class="o">=</span> <span class="n">tlx</span><span class="o">.</span><span class="n">mask_select</span><span class="p">(</span><span class="n">edge_index</span><span class="p">,</span> <span class="n">edge_type</span> <span class="o">==</span> <span class="n">i</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">src_types</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">tlx</span><span class="o">.</span><span class="n">convert_to_numpy</span><span class="p">(</span><span class="n">tlx</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">node_type</span><span class="p">,</span> <span class="n">src</span><span class="p">)))</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                <span class="n">dst_types</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">tlx</span><span class="o">.</span><span class="n">convert_to_numpy</span><span class="p">(</span><span class="n">tlx</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">node_type</span><span class="p">,</span> <span class="n">dst</span><span class="p">)))</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">src_types</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">dst_types</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;Could not construct a &#39;HeteroData&#39; object from the &quot;</span>
                        <span class="s2">&quot;&#39;Data&#39; object because single edge types span over &quot;</span>
                        <span class="s2">&quot;multiple node types&quot;</span><span class="p">)</span>
                <span class="n">edge_type_names</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">node_type_names</span><span class="p">[</span><span class="n">src_types</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">),</span>
                                        <span class="n">node_type_names</span><span class="p">[</span><span class="n">dst_types</span><span class="p">[</span><span class="mi">0</span><span class="p">]]))</span>

        <span class="c1"># We iterate over node types to find the local node indices belonging</span>
        <span class="c1"># to each node type. Furthermore, we create a global `index_map` vector</span>
        <span class="c1"># that maps global node indices to local ones in the final</span>
        <span class="c1"># heterogeneous graph:</span>
        <span class="n">node_ids</span><span class="p">,</span> <span class="n">index_map</span> <span class="o">=</span> <span class="p">{},</span> <span class="n">tlx</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">node_type</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">node_type_names</span><span class="p">):</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">tlx</span><span class="o">.</span><span class="n">convert_to_numpy</span><span class="p">((</span><span class="n">node_type</span> <span class="o">==</span> <span class="n">i</span><span class="p">))</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">node_ids</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">tlx</span><span class="o">.</span><span class="n">convert_to_tensor</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
            <span class="c1"># node_ids[i] = (node_type == i).nonzero(as_tuple=False).view(-1)</span>
            <span class="c1"># index_map[node_ids[i]] = tlx.arange(start=0, limit=len(node_ids[i]))</span>
            <span class="n">index_map</span> <span class="o">=</span> <span class="n">tlx</span><span class="o">.</span><span class="n">scatter_update</span><span class="p">(</span><span class="n">index_map</span><span class="p">,</span> <span class="n">node_ids</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                                           <span class="n">tlx</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">node_ids</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tlx</span><span class="o">.</span><span class="n">int64</span><span class="p">))</span>

        <span class="c1"># We iterate over edge types to find the local edge indices:</span>
        <span class="n">edge_ids</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">edge_type_names</span><span class="p">):</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">tlx</span><span class="o">.</span><span class="n">convert_to_numpy</span><span class="p">((</span><span class="n">edge_type</span> <span class="o">==</span> <span class="n">i</span><span class="p">))</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">edge_ids</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">tlx</span><span class="o">.</span><span class="n">convert_to_tensor</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
        <span class="c1"># edge_ids[i] = (edge_type == i).nonzero(as_tuple=False).view(-1)</span>

        <span class="n">data</span> <span class="o">=</span> <span class="n">HeteroGraph</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">node_type_names</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">attr</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">attr</span> <span class="o">==</span> <span class="s1">&#39;node_type&#39;</span> <span class="ow">or</span> <span class="n">attr</span> <span class="o">==</span> <span class="s1">&#39;edge_type&#39;</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">elif</span> <span class="n">tlx</span><span class="o">.</span><span class="n">is_tensor</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_node_attr</span><span class="p">(</span><span class="n">attr</span><span class="p">):</span>
                    <span class="n">data</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">attr</span><span class="p">]</span> <span class="o">=</span> <span class="n">tlx</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">node_ids</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">key</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">num_nodes</span> <span class="o">=</span> <span class="n">tlx</span><span class="o">.</span><span class="n">get_tensor_shape</span><span class="p">(</span><span class="n">node_ids</span><span class="p">[</span><span class="n">i</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">edge_type_names</span><span class="p">):</span>
            <span class="n">src</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">dst</span> <span class="o">=</span> <span class="n">key</span>
            <span class="k">for</span> <span class="n">attr</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">attr</span> <span class="o">==</span> <span class="s1">&#39;node_type&#39;</span> <span class="ow">or</span> <span class="n">attr</span> <span class="o">==</span> <span class="s1">&#39;edge_type&#39;</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">elif</span> <span class="n">attr</span> <span class="o">==</span> <span class="s1">&#39;edge_index&#39;</span><span class="p">:</span>
                    <span class="n">edge_index</span> <span class="o">=</span> <span class="n">tlx</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">edge_ids</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                    <span class="n">edge_index</span> <span class="o">=</span> <span class="n">tlx</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">tlx</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">index_map</span><span class="p">,</span> <span class="n">edge_index</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">tlx</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">index_map</span><span class="p">,</span> <span class="n">edge_index</span><span class="p">[</span><span class="mi">1</span><span class="p">])])</span>
                    <span class="n">data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">edge_index</span> <span class="o">=</span> <span class="n">edge_index</span>
                <span class="k">elif</span> <span class="n">tlx</span><span class="o">.</span><span class="n">is_tensor</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_edge_attr</span><span class="p">(</span><span class="n">attr</span><span class="p">):</span>
                    <span class="n">data</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">attr</span><span class="p">]</span> <span class="o">=</span> <span class="n">tlx</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">edge_ids</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

        <span class="c1"># Add global attributes.</span>
        <span class="n">keys</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">keys</span><span class="p">)</span> <span class="o">|</span> <span class="p">{</span><span class="s1">&#39;node_type&#39;</span><span class="p">,</span> <span class="s1">&#39;edge_type&#39;</span><span class="p">,</span> <span class="s1">&#39;num_nodes&#39;</span><span class="p">}</span>
        <span class="k">for</span> <span class="n">attr</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">node_stores</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">data</span><span class="o">.</span><span class="n">node_stores</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">attr</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">data</span><span class="p">[</span><span class="n">attr</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

        <span class="k">return</span> <span class="n">data</span></div>

    <span class="c1">###########################################################################</span>

<div class="viewcode-block" id="Graph.from_dict"><a class="viewcode-back" href="../../../generated/gammagl.data.Graph.html#gammagl.data.Graph.from_dict">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_dict</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">mapping</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Creates a :class:`~gammagl.data.Data` object from a Python</span>
<span class="sd">        dictionary.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="o">**</span><span class="n">mapping</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">num_node_features</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Returns the number of features per node in the graph.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_store</span><span class="o">.</span><span class="n">num_node_features</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">num_features</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Returns the number of features per node in the graph.</span>
<span class="sd">        Alias for :py:attr:`~num_node_features`.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_node_features</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">num_edge_features</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Returns the number of features per edge in the graph.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_store</span><span class="o">.</span><span class="n">num_edge_features</span>

    <span class="c1"># class `Graph` can&#39;t be collections.Iterable, or can&#39;t be saved in paddle.</span>
    <span class="c1"># def __iter__(self) -&gt; Iterable:</span>
    <span class="c1"># 	r&quot;&quot;&quot;Iterates over all attributes in the data, yielding their attribute</span>
    <span class="c1"># 	names and values.&quot;&quot;&quot;</span>
    <span class="c1"># 	for key, value in self._store.items():</span>
    <span class="c1"># 		yield key, value</span>

    <span class="c1"># do not use __iter__ function, or will throw exception in paddle backend.</span>
    <span class="c1"># So here use iter</span>
    <span class="c1"># now visit graph attr by for key, value in &quot;graph.iter()&quot;, instead of &quot;graph&quot;</span>
    <span class="k">def</span> <span class="nf">iter</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterable</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_store</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">yield</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Iterable</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Iterates over all attributes :obj:`*args` in the data, yielding</span>
<span class="sd">        their attribute names and values.</span>
<span class="sd">        If :obj:`*args` is not given, will iterate over all attributes.&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_store</span><span class="o">.</span><span class="n">items</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
            <span class="k">yield</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">x</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="s1">&#39;x&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_store</span> <span class="k">else</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">edge_index</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;edge_index&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="s1">&#39;edge_index&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_store</span> <span class="k">else</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">edge_weight</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;edge_weight&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="s1">&#39;edge_weight&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_store</span> <span class="k">else</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">edge_attr</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;edge_attr&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="s1">&#39;edge_attr&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_store</span> <span class="k">else</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">y</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;y&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="s1">&#39;y&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_store</span> <span class="k">else</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">pos</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;pos&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="s1">&#39;pos&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_store</span> <span class="k">else</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">batch</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;batch&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="s1">&#39;batch&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_store</span> <span class="k">else</span> <span class="kc">None</span>

    <span class="c1">###########################################################################</span>

<div class="viewcode-block" id="Graph.dump"><a class="viewcode-back" href="../../../generated/gammagl.data.Graph.html#gammagl.data.Graph.dump">[docs]</a>    <span class="k">def</span> <span class="nf">dump</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Dump the graph into a directory.</span>

<span class="sd">        This function will dump the graph information into the given directory path.</span>
<span class="sd">        The graph can be read back with :code:`pgl.Graph.load`</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        path: str</span>
<span class="sd">            The directory for the storage of the graph.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div>

    <span class="c1"># if self._is_tensor:</span>
    <span class="c1">#     # Convert back into numpy and dump.</span>
    <span class="c1">#     graph = self.numpy(inplace=False)</span>
    <span class="c1">#     graph.dump(path)</span>
    <span class="c1"># else:</span>
    <span class="c1">#     if not os.path.exists(path):</span>
    <span class="c1">#         os.makedirs(path)</span>

    <span class="c1">#     np.save(os.path.join(path, &#39;num_nodes.npy&#39;), self._num_nodes)</span>
    <span class="c1">#     np.save(os.path.join(path, &#39;edges.npy&#39;), self._edges)</span>
    <span class="c1">#     np.save(os.path.join(path, &#39;num_graph.npy&#39;), self._num_graph)</span>

    <span class="c1">#     if self._adj_src_index is not None:</span>
    <span class="c1">#         self._adj_src_index.dump(os.path.join(path, &#39;adj_src&#39;))</span>

    <span class="c1">#     if self._adj_dst_index is not None:</span>
    <span class="c1">#         self._adj_dst_index.dump(os.path.join(path, &#39;adj_dst&#39;))</span>

    <span class="c1">#     if self._graph_node_index is not None:</span>
    <span class="c1">#         np.save(</span>
    <span class="c1">#             os.path.join(path, &#39;graph_node_index.npy&#39;),</span>
    <span class="c1">#             self._graph_node_index)</span>

    <span class="c1">#     if self._graph_edge_index is not None:</span>
    <span class="c1">#         np.save(</span>
    <span class="c1">#             os.path.join(path, &#39;graph_edge_index.npy&#39;),</span>
    <span class="c1">#             self._graph_edge_index)</span>

    <span class="c1">#     def _dump_feat(feat_path, feat):</span>
    <span class="c1">#         &quot;&quot;&quot;Dump all features to .npy file.</span>
    <span class="c1">#         &quot;&quot;&quot;</span>
    <span class="c1">#         if len(feat) == 0:</span>
    <span class="c1">#             return</span>

    <span class="c1">#         if not os.path.exists(feat_path):</span>
    <span class="c1">#             os.makedirs(feat_path)</span>

    <span class="c1">#         for key in feat:</span>
    <span class="c1">#             value = feat[key]</span>
    <span class="c1">#             np.save(os.path.join(feat_path, key + &quot;.npy&quot;), value)</span>

    <span class="c1">#     _dump_feat(os.path.join(path, &quot;node_feat&quot;), self.node_feat)</span>
    <span class="c1">#     _dump_feat(os.path.join(path, &quot;edge_feat&quot;), self.edge_feat)</span>

<div class="viewcode-block" id="Graph.load"><a class="viewcode-back" href="../../../generated/gammagl.data.Graph.html#gammagl.data.Graph.load">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">load</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">mmap_mode</span><span class="o">=</span><span class="s2">&quot;r&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Load Graph from path and return a Graph in numpy.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        path: str</span>
<span class="sd">            The directory path of the stored Graph.</span>
<span class="sd">        mmap_mode: str</span>
<span class="sd">            Default :code:`mmap_mode=&quot;r&quot;`. If not None, memory-map the graph.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div></div>

<span class="c1"># num_nodes = np.load(</span>
<span class="c1">#     os.path.join(path, &#39;num_nodes.npy&#39;), mmap_mode=mmap_mode)</span>
<span class="c1"># edges = np.load(os.path.join(path, &#39;edges.npy&#39;), mmap_mode=mmap_mode)</span>
<span class="c1"># num_graph = np.load(</span>
<span class="c1">#     os.path.join(path, &#39;num_graph.npy&#39;), mmap_mode=mmap_mode)</span>
<span class="c1"># if os.path.exists(os.path.join(path, &#39;graph_node_index.npy&#39;)):</span>
<span class="c1">#     graph_node_index = np.load(</span>
<span class="c1">#         os.path.join(path, &#39;graph_node_index.npy&#39;),</span>
<span class="c1">#         mmap_mode=mmap_mode)</span>
<span class="c1"># else:</span>
<span class="c1">#     graph_node_index = None</span>

<span class="c1"># if os.path.exists(os.path.join(path, &#39;graph_edge_index.npy&#39;)):</span>
<span class="c1">#     graph_edge_index = np.load(</span>
<span class="c1">#         os.path.join(path, &#39;graph_edge_index.npy&#39;),</span>
<span class="c1">#         mmap_mode=mmap_mode)</span>
<span class="c1"># else:</span>
<span class="c1">#     graph_edge_index = None</span>

<span class="c1"># if os.path.isdir(os.path.join(path, &#39;adj_src&#39;)):</span>
<span class="c1">#     adj_src_index = EdgeIndex.load(</span>
<span class="c1">#         os.path.join(path, &#39;adj_src&#39;), mmap_mode=mmap_mode)</span>
<span class="c1"># else:</span>
<span class="c1">#     adj_src_index = None</span>

<span class="c1"># if os.path.isdir(os.path.join(path, &#39;adj_dst&#39;)):</span>
<span class="c1">#     adj_dst_index = EdgeIndex.load(</span>
<span class="c1">#         os.path.join(path, &#39;adj_dst&#39;), mmap_mode=mmap_mode)</span>
<span class="c1"># else:</span>
<span class="c1">#     adj_dst_index = None</span>

<span class="c1"># def _load_feat(feat_path):</span>
<span class="c1">#     &quot;&quot;&quot;Load features from .npy file.</span>
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#     feat = {}</span>
<span class="c1">#     if os.path.isdir(feat_path):</span>
<span class="c1">#         for feat_name in os.listdir(feat_path):</span>
<span class="c1">#             feat[os.path.splitext(feat_name)[0]] = np.load(</span>
<span class="c1">#                 os.path.join(feat_path, feat_name),</span>
<span class="c1">#                 mmap_mode=mmap_mode)</span>
<span class="c1">#     return feat</span>

<span class="c1"># node_feat = _load_feat(os.path.join(path, &#39;node_feat&#39;))</span>
<span class="c1"># edge_feat = _load_feat(os.path.join(path, &#39;edge_feat&#39;))</span>
<span class="c1"># return cls(edges=edges,</span>
<span class="c1">#            num_nodes=num_nodes,</span>
<span class="c1">#            node_feat=node_feat,</span>
<span class="c1">#            edge_feat=edge_feat,</span>
<span class="c1">#            adj_src_index=adj_src_index,</span>
<span class="c1">#            adj_dst_index=adj_dst_index,</span>
<span class="c1">#            _num_graph=num_graph,</span>
<span class="c1">#            _graph_node_index=graph_node_index,</span>
<span class="c1">#            _graph_edge_index=graph_edge_index)</span>


<span class="k">def</span> <span class="nf">size_repr</span><span class="p">(</span><span class="n">key</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="n">indent</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="n">pad</span> <span class="o">=</span> <span class="s1">&#39; &#39;</span> <span class="o">*</span> <span class="n">indent</span>
    <span class="k">if</span> <span class="n">tlx</span><span class="o">.</span><span class="n">is_tensor</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="ow">and</span> <span class="n">value</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
    <span class="k">elif</span> <span class="n">tlx</span><span class="o">.</span><span class="n">is_tensor</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
        <span class="n">out</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="n">out</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
    <span class="c1"># elif isinstance(value, SparseTensor):</span>
    <span class="c1">#     out = str(value.sizes())[:-1] + f&#39;, nnz={value.nnz()}]&#39;</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">out</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;&#39;</span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2">&#39;&quot;</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">):</span>
        <span class="n">out</span> <span class="o">=</span> <span class="nb">str</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)])</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">Mapping</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">out</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">&#39;</span>
    <span class="k">elif</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">Mapping</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
          <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">values</span><span class="p">())[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Mapping</span><span class="p">)):</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="p">[</span><span class="n">size_repr</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">value</span><span class="o">.</span><span class="n">items</span><span class="p">()]</span>
        <span class="n">out</span> <span class="o">=</span> <span class="s1">&#39;{ &#39;</span> <span class="o">+</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; }&#39;</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">Mapping</span><span class="p">):</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="p">[</span><span class="n">size_repr</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">indent</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">value</span><span class="o">.</span><span class="n">items</span><span class="p">()]</span>
        <span class="n">out</span> <span class="o">=</span> <span class="s1">&#39;{</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">+</span> <span class="s1">&#39;,</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">+</span> <span class="n">pad</span> <span class="o">+</span> <span class="s1">&#39;}&#39;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">out</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

    <span class="n">key</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">key</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;&#39;&quot;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">BaseStorage</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">pad</span><span class="si">}</span><span class="se">\033</span><span class="s1">[1m</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="se">\033</span><span class="s1">[0m=</span><span class="si">{</span><span class="n">out</span><span class="si">}</span><span class="s1">&#39;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">pad</span><span class="si">}{</span><span class="n">key</span><span class="si">}</span><span class="s1">=</span><span class="si">{</span><span class="n">out</span><span class="si">}</span><span class="s1">&#39;</span>
</pre></div>

           </div>
           
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2023, BUPT-GAMMA LAB.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>